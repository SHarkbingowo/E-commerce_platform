# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oZCneCgEGsVuAFlh01f1ab5fO0ooSAVb
"""

!pip install texthero
# Basic libraries
import numpy as np # linear algebra
import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)
import datetime as dt
from scipy import stats
import json

# NLP libraries
import texthero as hero
from nltk.tokenize import ToktokTokenizer

# Data visualization libraries
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots



# Sklearn libraries
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.model_selection import train_test_split
from sklearn import model_selection

from sklearn.dummy import DummyClassifier
from sklearn.naive_bayes import MultinomialNB
from sklearn.linear_model import SGDClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.svm import LinearSVC
from sklearn.linear_model import Perceptron
from sklearn.linear_model import PassiveAggressiveClassifier
from sklearn.neural_network import MLPClassifier
from sklearn.ensemble import RandomForestClassifier

from sklearn.metrics import accuracy_score
from sklearn import preprocessing
from xgboost import XGBClassifier
from xgboost import plot_importance

from google.colab import drive
drive.mount('/content/drive')
# 导入数据 转换日期格式
df = pd.read_csv("drive/My Drive/Colab Notebooks/records.csv",
                   parse_dates=["InvoiceDate"])
df

df = df.dropna(subset=["CustomerID"])
print('Duplicate entries: {}'.format(df.duplicated().sum()))
df.drop_duplicates(inplace = True)

# 处理折扣和邮费
# 折扣
df['Discount'] = 0
for index, col in  df[df['StockCode']=='D'].iterrows(): #逐行遍历
    invoice = col['InvoiceNo']   #根据invoiceno检索
    price = col['UnitPrice']
    
    df.loc[(df.InvoiceNo == invoice), 'Discount'] = price
# 邮费
df['Postage'] = 0
for index, col in  df[df['StockCode']=='POST'].iterrows():
    invoice = col['InvoiceNo']
    price = col['UnitPrice']
    
    df.loc[(df.InvoiceNo == invoice), 'Postage'] = price
# StockCode包含怪异字符的
list_special_codes = df[df['StockCode'].str.contains('^[a-zA-Z]+', regex=True)]['StockCode'].unique()
list_special_codes 
# 去除怪异字符
for code in list_special_codes : 
    df = df[df['StockCode']!= code]
df

#退单处理
df_cleaned = df.copy(deep = True)
df_cleaned['QuantityCanceled'] = 0

entry_to_remove = [] ; doubtfull_entry = []

for index, col in  df.iterrows():
    if (col['Quantity'] > 0) or col['Description'] == 'Discount': continue        
    df_test = df[(df['CustomerID'] == col['CustomerID']) &
                         (df['StockCode']  == col['StockCode']) & 
                         (df['InvoiceDate'] < col['InvoiceDate']) & 
                         (df['Quantity']   > 0)].copy()
    #全表遍历，如果销量为正或有折扣，继续，保存至df_test
    # Cancelation WITHOUT counterpart  维数为0
    if (df_test.shape[0] == 0): 
        doubtfull_entry.append(index)
    #________________________________ 
    # Cancelation WITH a counterpart 维数为1
    elif (df_test.shape[0] == 1): 
        index_order = df_test.index[0]
        df_cleaned.loc[index_order, 'QuantityCanceled'] = -col['Quantity']
        entry_to_remove.append(index)        
    #______________________________________________________________
    # Various counterparts exist in orders: we delete the last one 维数大于1，
    elif (df_test.shape[0] > 1): 
        df_test.sort_index(axis=0 ,ascending=False, inplace = True)        
        for ind, val in df_test.iterrows(): #将一组字符型数据的数字部分转换成相应的数值型数据
            if val['Quantity'] < -col['Quantity']: continue  #销量负数大于销量
            df_cleaned.loc[ind, 'QuantityCanceled'] = -col['Quantity']
            entry_to_remove.append(index) 
            break

print("entry_to_remove: {}".format(len(entry_to_remove)))
print("doubtfull_entry: {}".format(len(doubtfull_entry)))

df_cleaned.drop(entry_to_remove, axis = 0, inplace = True)
df_cleaned.drop(doubtfull_entry, axis = 0, inplace = True)
remaining_entries = df_cleaned[(df_cleaned['Quantity'] < 0) & (df_cleaned['StockCode'] != 'D')]
print("nb of entries to delete: {}".format(remaining_entries.shape[0]))
remaining_entries[:5]

df_cleaned.drop(remaining_entries.index, axis = 0, inplace = True)

# 处理描述信息
product_df = df_cleaned.drop(columns=['StockCode', 'InvoiceNo', 'CustomerID', 'UnitPrice', 'Quantity', 'InvoiceDate', 'Country'])
product_df['Description'] = df['Description'].pipe(hero.clean)

tw = hero.visualization.top_words(product_df['Description']).head(40)

fig = px.bar(tw)
fig.show()

"""从这张图中，我决定从产品描述中做出3个不同的特征:颜色，类别和设计。我将在设计中分组几个东西，因为它会像产品的特性。比如"Retrospot"， "Vintage"， "Feltcraft"…在分类中，我们会有“蛋糕”、“圣诞”、“瓶子”"""

# 颜色
token = ToktokTokenizer()
def TagExtractor(text, tags): #特征提取
    
    words=token.tokenize(text)
    
    filtered = [w for w in words if  w in tags]
    
    return ' '.join(map(str, filtered))

def TagRemove(text, tags):  #特征移去
    
    words=token.tokenize(text)
    
    filtered = [w for w in words if not w in tags]
    
    return ' '.join(map(str, filtered))

colors = ['black', 'blue', 'brown', 'gold', 'green', 'grey', 'orange', 'pink', 'purple', 'red', 'silver', 'white', 'yellow', 'ivory']

product_df['ProductColor'] = product_df['Description'].apply(lambda x: TagExtractor(x, colors)) 

product_df['Description'] = product_df['Description'].apply(lambda x: TagRemove(x, colors))

tw = hero.visualization.top_words(product_df['ProductColor']).head(20)

fig = px.bar(tw)
fig.show()

"""为了提取颜色，我基本上做了一个颜色列表，并编写了一个函数，它将在数据帧中迭代，每个产品描述将被分割成文字。如果我们在产品描述中找到一种颜色，我们就把它放在一个列表中。这个功能可能非常有趣，因为我们可以知道客户是否有最喜欢的颜色，这可能会导致公司的个性化营销活动。"""

# 产品设计样式
Design = ['gingham', 'butterfly', 'chocolate', 'zinc', 'hearts', 'star', 'skull', 'dolly', 'wood', 'retro', 'strawberry',
         'mini', 'polkadot', 'spot', 'cream', 'rose', 'spaceboy', 'ceramic', 'glasse', 'vintage', 'retrospot', 'heart',
         'spots', 'skulls', 'scandinavian', 'london', 'french', 'wooden', 'woodland', 'bakelike', 'feltrcraft', 'porcelain',
         'spaceboy', 'glass', 'traditional', 'bird', 'birds', 'flower', 'antique', 'tube']
product_df['Design'] = product_df['Description'].apply(lambda x: TagExtractor(x, Design)) 
stop_words = ['set', 'pack', 'small', 'large']
product_df['Description'] = product_df['Description'].apply(lambda x: TagRemove(x, (Design+stop_words))) 
tw = hero.visualization.top_words(product_df['Design']).head(20)

fig = px.bar(tw)
fig.show()

# 产品目录类别
Categories = ['bag', 'box', 'cake', 'christmas', 'hanging', 'light', 'holder', 'sign', 'jumbo', 'lunch', 'paper', 'tea', 'card',
              'cases', 'decoration', 'water', 'bottle', 'mug', 'party', 'garden', 'wrap', 'bowl', 'birthday', 
              'photo', 'frame', 'candle', 'key', 'ring', 'travel', 'egg', 'cup', 
              'lights', 'cutlery', 'candles', 'door', 'gift', 'clock', 'trinket', 
              'drawer', 'stand', 'pencils', 'ribbons', 'napkins', 'notebook', 'photo', 'alarm', 'dog',
             'kitchen', 'storage', 'childrens', 'cup', 'cat', 'wall', 'art', 'cushion', 'cover', 'popcorn', 'soap', 'baking', 'door']
product_df['Categories'] = product_df['Description'].apply(lambda x: TagExtractor(x, Categories)) 
tw = hero.visualization.top_words(product_df['Categories']).head(20)
fig = px.bar(tw)
fig.show()

pd.DataFrame(product_df['Categories'].value_counts()).to_excel('drive/My Drive/Colab Notebooks/product_categories.xlsx')

product_df

product_tags = pd.read_excel('drive/My Drive/Colab Notebooks/product_categories V2.xlsx')

product_tags.head()

product_df = product_df.reset_index().merge(product_tags, on='Categories', how='left').set_index('index')

product_df.loc[(product_df.Description =='wicker'), 'Labels'] = 'Wicker'

product_df.loc[(product_df.Description =='assorted colour ornament'), 'Labels'] = 'Home Decoration'

product_df.loc[(product_df.Description =='tissues'), 'Labels'] = 'Essentials'

product_df.loc[(product_df.Description =='chalkboard'), 'Labels'] = 'Stationary'

product_df.loc[(product_df.Description =='milk jug'), 'Labels'] = 'Tableware'

product_df.loc[(product_df.Description =='measuring spoons'), 'Labels'] = 'Baking'

product_df.loc[(product_df.Description =='snap cards'), 'Labels'] = 'Cards'

product_df.loc[(product_df.Description =='regency cakestand tier'), 'Labels'] = 'Cake Decoration'

product_df.loc[(product_df.Description =='heart wicker small'), 'Labels'] = 'Hanging Decoration'

product_df.loc[(product_df.Description =='heart wicker large'), 'Labels'] = 'Hanging Decoration'

product_df.loc[(product_df.Description =='edwardian parasol'), 'Labels'] = 'Essentials'

product_df.loc[(product_df.Description =='regency teacup saucer'), 'Labels'] = 'Tea'

product_df.loc[(product_df.Description =='natural slate heart chalkboard'), 'Labels'] = 'Home Decoration'

product_df.loc[(product_df.Description =='french metal door sign'), 'Labels'] = 'Door Sign'

product_df.loc[(product_df.Description =='love building block word'), 'Labels'] = 'Home Decoration'

product_df.loc[(product_df.Description =='vintage snap cards'), 'Labels'] = 'Cards'

product_df.loc[(product_df.Description =='scottie dog hot water bottle'), 'Labels'] = 'Water Bottle'

product_df.loc[(product_df.Labels =='Holders'), 'Labels'] = 'Holding Decoration'

for label in ['Decorative Storage', 'Hanging Decoration', 'Lights', 'Candles', 'Door Signs', 'Wall Signs', 'Wicker', 'Clocks',
             'Storage', 'Frame', 'Photo Frame', 'Wall Art', 'Holding Decoration', 'Popcorn Holder']:
    product_df.loc[(product_df.Labels ==label), 'Labels'] = 'Home Decoration'

for label in ['Lunch Bags', 'Jumbo Bags', 'Jumbo Shopper']:
    product_df.loc[(product_df.Labels ==label), 'Labels'] = 'Bags'

for label in ['Cards', 'Paper', 'Cushions', 'Wraps', 'Gift Wraps']:
    product_df.loc[(product_df.Labels ==label), 'Labels'] = 'Gifts'

for label in ['Water Bottle', 'Essentials', 'Travel', 'Pets', 'Jewelry']:
    product_df.loc[(product_df.Labels ==label), 'Labels'] = 'Other'

for label in ['Cake Decoration', 'Birthday']:
    product_df.loc[(product_df.Labels ==label), 'Labels'] = 'Party'
    
for label in ['Tea', 'Baking', 'Kitchen', 'Soap']:
    product_df.loc[(product_df.Labels ==label), 'Labels'] = 'Tableware'

product_df

product_df['Labels'].value_counts().sum() /product_df['Labels'].shape[0]*100

"""最后一笔，我们就完成了。在这种半手动的工作中，几乎60%的数据被标记，这应该为我们的下一步提供足够的数据"""

# 训练分类算法
X = product_df.dropna(subset=['Labels']).drop_duplicates(subset=['Description'])['Description']
X_test = product_df[product_df['Labels'].isnull()]['Description']

X.shape, X_test.shape

le = preprocessing.LabelEncoder()
y = le.fit_transform(product_df.dropna(subset=['Labels']).drop_duplicates(subset=['Description'])['Labels'])

X_train, X_val, y_train, y_val = train_test_split(X, y, test_size = 0.4, random_state = 46) # Do 60/40 split
X_vectorizer = TfidfVectorizer(analyzer = 'word',
                            )
X_train = X_vectorizer.fit_transform(X_train)
X_val =  X_vectorizer.transform(X_val)
X_test_tfidf = X_vectorizer.transform(X_test)
def print_score(y_pred, clf):
    print("Clf: ", clf.__class__.__name__)
    print("Accuracy score: {}".format(accuracy_score(y_val, y_pred)))
    print("---")   

dummy = DummyClassifier(strategy='prior')
sgd = SGDClassifier()
mn = MultinomialNB()
svc = LinearSVC()
perceptron = Perceptron()
pac = PassiveAggressiveClassifier()
mlpc = MLPClassifier()
rfc = RandomForestClassifier()
xgb = XGBClassifier()


for classifier in [dummy, sgd, mn, svc, perceptron, pac, mlpc, rfc, xgb]:
    classifier.fit(X_train, y_train)
    y_pred = classifier.predict(X_val)
    print_score(y_pred, classifier)

# 我们可以通过调优一些参数得到更好的结果，但现在我将保持这种方式，稍后再回来讨论它。
y_pred_test = rfc.predict(X_test_tfidf)
prods_non_labeled = pd.DataFrame()
prods_non_labeled['Description']= X_test
prods_non_labeled['Labels'] = le.inverse_transform(y_pred_test)
prods_non_labeled

product_df.loc[(product_df.Labels.isnull()), 'Labels'] = prods_non_labeled['Labels']
product_df

df_cleaned['ProductColor'] = product_df['ProductColor']
df_cleaned['Design'] = product_df['Design']
df_cleaned['Labels'] = product_df['Labels']

df_cleaned['Labels'].value_counts(dropna=False)

# 特征工程
# 总额
df_cleaned['TotalPrice'] = df_cleaned['UnitPrice'] * (df_cleaned['Quantity'] - df_cleaned['QuantityCanceled'])
df_cleaned[df_cleaned['TotalPrice']<0]
df_cleaned.drop(df_cleaned[df_cleaned['TotalPrice']<0].index, axis = 0, inplace = True)#删除退单数大于订单数的
z = np.abs(stats.zscore(df_cleaned['TotalPrice']))#离群值处理
threshold = 10

df_cleaned_outliers = df_cleaned.copy(deep=True)
df_cleaned_outliers['Outliers'] = z

df_cleaned_outliers[df_cleaned_outliers['Outliers']>threshold]

df_cleaned.drop(df_cleaned_outliers[df_cleaned_outliers['Outliers']>threshold].index, axis = 0, inplace = True)

#时间
df_cleaned['InvoiceDate'] = pd.to_datetime(df_cleaned['InvoiceDate'])
df_cleaned['Year'] = df_cleaned["InvoiceDate"].apply(lambda x: x.year)
df_cleaned['Month'] = df_cleaned["InvoiceDate"].apply(lambda x: x.month)
df_cleaned['MonthYear'] = df_cleaned["InvoiceDate"].apply(lambda x: x.strftime("%B %Y"))
df_cleaned['Weekday'] = df_cleaned["InvoiceDate"].apply(lambda x: x.weekday())
df_cleaned['Day'] = df_cleaned["InvoiceDate"].apply(lambda x: x.day)
df_cleaned['Hour'] = df_cleaned["InvoiceDate"].apply(lambda x: x.hour)

#RFM
df_cleaned['InvoiceDate'].min()

df_cleaned['InvoiceDate'].max()

NOW = dt.datetime(2011,12,1)

df_cleaned.shape[0] / df_cleaned['InvoiceNo'].value_counts().count()

custom_aggregation = {}
custom_aggregation["InvoiceDate"] = lambda x:x.iloc[0]
custom_aggregation["CustomerID"] = lambda x:x.iloc[0]
custom_aggregation["TotalPrice"] = "sum"
rfmTable = df_cleaned.groupby("InvoiceNo").agg(custom_aggregation)
rfmTable["Recency"] = NOW - rfmTable["InvoiceDate"]
rfmTable["Recency"] = pd.to_timedelta(rfmTable["Recency"]).astype("timedelta64[D]")

custom_aggregation = {}

custom_aggregation["Recency"] = ["min", "max"]
custom_aggregation["InvoiceDate"] = lambda x: len(x)
custom_aggregation["TotalPrice"] = "sum"

rfmTable_final = rfmTable.groupby("CustomerID").agg(custom_aggregation)
rfmTable_final.columns = ["min_recency", "max_recency", "frequency", "monetary_value"]

first_customer = df_cleaned[df_cleaned['CustomerID']==12346.0]

quantiles = rfmTable_final.quantile(q=[0.25,0.5,0.75])
quantiles = quantiles.to_dict()

segmented_rfm = rfmTable_final

def RScore(x,p,d):
    if x <= d[p][0.25]:
        return 1
    elif x <= d[p][0.50]:
        return 2
    elif x <= d[p][0.75]: 
        return 3
    else:
        return 4
    
def FMScore(x,p,d):
    if x <= d[p][0.25]:
        return 4
    elif x <= d[p][0.50]:
        return 3
    elif x <= d[p][0.75]: 
        return 2
    else:
        return 1

segmented_rfm['R'] = segmented_rfm['min_recency'].apply(RScore, args=('min_recency',quantiles,))
segmented_rfm['F'] = segmented_rfm['frequency'].apply(FMScore, args=('frequency',quantiles,))
segmented_rfm['M'] = segmented_rfm['monetary_value'].apply(FMScore, args=('monetary_value',quantiles,))
segmented_rfm.head()

segmented_rfm['RFMScore'] = segmented_rfm.R.map(str) + segmented_rfm.F.map(str) + segmented_rfm.M.map(str)
segmented_rfm.head()

segmented_rfm = segmented_rfm.reset_index()
segmented_rfm.head(5)

df_cleaned = pd.merge(df_cleaned,segmented_rfm, on='CustomerID')

# 产品类别金额
for label in df_cleaned['Labels'].unique():
    col = 'Label_{}'.format(label)        
    df_temp = df_cleaned[df_cleaned['Labels'] == label]
    price_temp = df_temp['TotalPrice']
    df_cleaned.loc[:, col] = price_temp
    df_cleaned[col].fillna(0, inplace = True)

dg = df_cleaned.copy()
def user_segment(dg):
    X = [1, 2, 3, 4]
    if ((dg['F'] == 1) & (dg['R'] == 1) & (dg['M'] == 1)) &(dg['RFMScore'] == '111'):
        return 'Core'
    elif ((dg['F'] == 1) & (dg['R'] <= 2) & (dg['M'] == 1)) & (dg['RFMScore'] != '111'):
        return 'Loyal'
    elif ((dg['M'] == 1) & (dg['R'] >= 1) & (dg['F'] <= 2)) & (dg['RFMScore'] != '111'):
        return 'Whales'
    # elif (dg['F'] == 1) & (dg['M'] == 3 | dg['M'] == 4) & (dg['R'] >= 1):
    #     return 'Promising'
    elif (dg['F'] == 1) & (dg['M'] >= 2) & (dg['R'] >= 1):
        return 'Promising'
    elif (dg['F'] == 2) & (dg['M'] >= 1) & (dg['R'] >= 1):
        return 'Normal'
    elif (dg['R'] == 1) & (dg['F'] == 4) & (dg['M'] >= 1):
        return 'Rookies'
    elif (dg['R'] == 4) & (dg['F'] == 4) & (dg['M'] >= 1):
        return 'Slipping'
    else:
        return 'Normal'

dg['Segment'] = dg.apply(user_segment, axis=1)
dg.head()

dg.loc[dg.Segment.isnull()]['RFMScore'].value_counts()

custom_aggregation = {}

custom_aggregation["InvoiceDate"] = lambda x:x.iloc[0]
custom_aggregation["MonthYear"] = lambda x:x.iloc[0]

custom_aggregation["TotalPrice"] = 'sum'

sales_invoices_montly = df_cleaned.groupby('MonthYear').agg(custom_aggregation).sort_values(by='InvoiceDate')
sales_invoices_montly.head()

data = [go.Scatter(x=sales_invoices_montly.index, 
                   y=sales_invoices_montly['TotalPrice'])]

layout = go.Layout(title="Total sales", title_x=0.5)

fig = go.Figure(data=data, layout=layout)
fig.update_xaxes(type='category')

fig.show()

year_options = []
for year in df_cleaned['Year'].unique():
    year_options.append({'label':str(year), 'value':year})
year_options.append({'label':'All', 'value':'All'})

customer_country=df_cleaned[['Country','CustomerID']].drop_duplicates()
df_cleaned_grouped = customer_country.groupby(['Country'])['CustomerID'].aggregate('count').reset_index().sort_values('CustomerID', ascending=False)


filtered_df_2009 = df_cleaned[df_cleaned['Year']==2009]
customer_country_2009=filtered_df_2009[['Country','CustomerID']].drop_duplicates()
filtered_df_2009_grouped = customer_country_2009.groupby(['Country'])['CustomerID'].aggregate('count').reset_index().sort_values('CustomerID', ascending=False)

filtered_df_2010 = df_cleaned[df_cleaned['Year']==2010]
customer_country_2010=filtered_df_2010[['Country','CustomerID']].drop_duplicates()
filtered_df_2010_grouped = customer_country_2010.groupby(['Country'])['CustomerID'].aggregate('count').reset_index().sort_values('CustomerID', ascending=False)

filtered_df_2011 = df_cleaned[df_cleaned['Year']==2011]
customer_country_2011=filtered_df_2011[['Country','CustomerID']].drop_duplicates()
filtered_df_2011_grouped = customer_country_2011.groupby(['Country'])['CustomerID'].aggregate('count').reset_index().sort_values('CustomerID', ascending=False)

data = [go.Choropleth(
                locations = df_cleaned_grouped['Country'],
                locationmode = 'country names',
                z = df_cleaned_grouped['CustomerID'],
                text = df_cleaned_grouped['Country'],
                colorscale = 'Rainbow',
                marker_line_color='darkgray',
                marker_line_width=0.5,
                colorbar_title = 'Customers',
                ),
        go.Choropleth(
                locations = filtered_df_2009_grouped['Country'],
                locationmode = 'country names',
                z = filtered_df_2009_grouped['CustomerID'],
                text = filtered_df_2009_grouped['Country'],
                colorscale = 'Rainbow',
                marker_line_color='darkgray',
                marker_line_width=0.5,
                colorbar_title = 'Customers',
                ),
        go.Choropleth(
                locations = filtered_df_2010_grouped['Country'],
                locationmode = 'country names',
                z = filtered_df_2010_grouped['CustomerID'],
                text = filtered_df_2010_grouped['Country'],
                colorscale = 'Rainbow',
                marker_line_color='darkgray',
                marker_line_width=0.5,
                colorbar_title = 'Customers',
                ),
        go.Choropleth(
                locations = filtered_df_2011_grouped['Country'],
                locationmode = 'country names',
                z = filtered_df_2011_grouped['CustomerID'],
                text = filtered_df_2011_grouped['Country'],
                colorscale = 'Rainbow',
                marker_line_color='darkgray',
                marker_line_width=0.5,
                colorbar_title = 'Customers',
                ),
       ]

layout = go.Layout(
                title_text='Our customers',
                title_x=0.5,
                geo=dict(
                    showframe=False,
                    showcoastlines=False,
                    projection_type='equirectangular'
                ),
                )

fig = go.Figure(data=data, layout=layout)

# Add dropdown 
fig.update_layout( 
    updatemenus=[ 
        dict( 
            active=0, 
            buttons=list([ 
                dict(label="All", 
                     method="update", 
                     args=[{"visible": [True, False, False, False]}, 
                           {"title": "All customers"}]), 
                dict(label="2009", 
                     method="update", 
                     args=[{"visible": [False, True, False, False]}, 
                           {"title": "Customers in 2009", 
                            }]), 
                dict(label="2010", 
                     method="update", 
                     args=[{"visible": [False, False, True, False]}, 
                           {"title": "Customers in 2010", 
                            }]), 
                dict(label="2011", 
                     method="update", 
                     args=[{"visible": [False, False, False, True]}, 
                           {"title": "Customers in 2011", 
                            }]), 
            ]), 
        ) 
    ]) 
  
fig.show()

df_cleaned.groupby('Country')['TotalPrice'].sum().sort_values(ascending=False)[:6]

countries = ['EIRE', 'Netherlands', 'Germany', 'France', 'Australia'] 

countries_options = []
data = []
for country in countries:
    year_options.append({'label':str(country), 'value':country})

for country in countries:
    df_segment = df_cleaned[df_cleaned['Country']==country]
    df_segment_grouped = df_segment.groupby('MonthYear').agg(custom_aggregation).sort_values(by='InvoiceDate')
    
    data.append(go.Bar(x=df_segment_grouped.index, 
                   y=df_segment_grouped['TotalPrice']))

layout = go.Layout(
                title_text='Our customers',
                title_x=0.5,
                geo=dict(
                    showframe=False,
                    showcoastlines=False,
                    projection_type='equirectangular'
                ),
                )

fig = go.Figure(data=data, layout=layout)

# Add dropdown 
fig.update_layout( 
    updatemenus=[ 
        dict( 
            active=0, 
            buttons=list([ 
                dict(label=countries[0], 
                     method="update", 
                     args=[{"visible": [True, False, False, False, False]}, 
                           {"title": "{} sells".format(countries[0])}]), 
                dict(label=countries[1], 
                     method="update", 
                     args=[{"visible": [False, True, False, False, False]}, 
                           {"title": "{} sells".format(countries[1])}]), 
                dict(label=countries[2], 
                     method="update", 
                     args=[{"visible": [False, False, True, False, False]}, 
                           {"title": "{} sells".format(countries[2])}]), 
                dict(label=countries[3], 
                     method="update", 
                     args=[{"visible": [False, False, False, True, False]}, 
                           {"title": "{} sells".format(countries[3])}]), 
                dict(label=countries[4], 
                     method="update", 
                     args=[{"visible": [False, False, False, False, True]}, 
                           {"title": "{} sells".format(countries[4])}]), 
                
            ]), 
        ) 
    ]) 
  
fig.show()

i = 1
j = 1
data = []
segment_names = ['Core', 'Loyal', 'Whales', 'Promising', 'Normal', 
                 'Rookies', 'Slipping']
for segment in segment_names:
    df_segment = dg[dg['Segment']==segment]
    df_segment_grouped = df_segment.groupby('MonthYear').agg(custom_aggregation).sort_values(by='InvoiceDate')
    
    data.append(go.Scatter(x=df_segment_grouped.index, 
                   y=df_segment_grouped['TotalPrice']))
    
fig = make_subplots(rows=3, cols=3, shared_yaxes=True, vertical_spacing=0.09, subplot_titles=(segment_names[0], segment_names[1], segment_names[2], segment_names[3], segment_names[4], segment_names[5], 
                                  segment_names[6]))       

fig.add_trace(data[0], row=1, col=1)
fig.add_trace(data[1], row=1, col=2)
fig.add_trace(data[2], row=1, col=3)
fig.add_trace(data[3], row=2, col=1)
fig.add_trace(data[4], row=2, col=2)
fig.add_trace(data[5], row=2, col=3)
fig.add_trace(data[6], row=3, col=1)


fig.update_layout(height=1400, width=1400, title_text="Sales Through segments", title_x=0.5
                  )
for i in fig['layout']['annotations']:
    i['font'] = dict(size=10,color='#ff0000')
fig.show()

!pip install -U kaleido
fig.write_image('drive/My Drive/Colab Notebooks/777.png')